"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDefaultCertificateManager = exports.OPCUACertificateManager = void 0;
/**
 * @module node-opcua-certificate-manager
 */
// tslint:disable:no-empty
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const mkdirp = __importStar(require("mkdirp"));
const env_paths_1 = __importDefault(require("env-paths"));
const node_opcua_debug_1 = require("node-opcua-debug");
const node_opcua_crypto_1 = require("node-opcua-crypto");
const node_opcua_pki_1 = require("node-opcua-pki");
const node_opcua_status_code_1 = require("node-opcua-status-code");
const node_opcua_assert_1 = require("node-opcua-assert");
const node_opcua_object_registry_1 = require("node-opcua-object-registry");
const paths = (0, env_paths_1.default)("node-opcua-default");
const debugLog = (0, node_opcua_debug_1.make_debugLog)(__filename);
const errorLog = (0, node_opcua_debug_1.make_errorLog)(__filename);
const doDebug = (0, node_opcua_debug_1.checkDebugFlag)(__filename);
class OPCUACertificateManager extends node_opcua_pki_1.CertificateManager {
    /* */
    constructor(options) {
        options = options || {};
        const location = options.rootFolder || paths.config;
        if (!fs.existsSync(location)) {
            try {
                mkdirp.sync(location);
            }
            catch (err) {
                errorLog(" cannot create folder ", location, fs.existsSync(location));
            }
        }
        const _options = {
            keySize: options.keySize || 2048,
            location
        };
        super(_options);
        this.referenceCounter = 0;
        this.automaticallyAcceptUnknownCertificate = !!options.automaticallyAcceptUnknownCertificate;
    }
    initialize(...args) {
        const callback = args[0];
        (0, node_opcua_assert_1.assert)(callback && typeof callback === "function");
        return super.initialize(callback);
    }
    dispose() {
        const _super = Object.create(null, {
            dispose: { get: () => super.dispose }
        });
        return __awaiter(this, void 0, void 0, function* () {
            if (this.referenceCounter === 0) {
                yield _super.dispose.call(this);
            }
            else {
                this.referenceCounter--;
            }
        });
    }
    checkCertificate(certificateChain, callback) {
        // istanbul ignore next
        if (!callback || typeof callback !== "function") {
            throw new Error("Internal error");
        }
        this.verifyCertificate(certificateChain, (err1, status) => {
            // istanbul ignore next
            if (err1) {
                return callback(err1);
            }
            const statusCode = node_opcua_status_code_1.StatusCodes[status];
            const certificates = (0, node_opcua_crypto_1.split_der)(certificateChain);
            debugLog("checkCertificate => StatusCode = ", statusCode.toString());
            if (statusCode.equals(node_opcua_status_code_1.StatusCodes.BadCertificateUntrusted)) {
                const topCertificateInChain = certificates[0];
                const thumbprint = (0, node_opcua_crypto_1.makeSHA1Thumbprint)(topCertificateInChain).toString("hex");
                if (this.automaticallyAcceptUnknownCertificate) {
                    debugLog("automaticallyAcceptUnknownCertificate = true");
                    debugLog("certificate with thumbprint " + thumbprint + " is now trusted");
                    return this.trustCertificate(topCertificateInChain, () => callback(null, node_opcua_status_code_1.StatusCodes.Good));
                }
                else {
                    debugLog("automaticallyAcceptUnknownCertificate = false");
                    debugLog("certificate with thumbprint " + thumbprint + " is now rejected");
                    return this.rejectCertificate(topCertificateInChain, () => callback(null, node_opcua_status_code_1.StatusCodes.BadCertificateUntrusted));
                }
            }
            else if (statusCode.equals(node_opcua_status_code_1.StatusCodes.BadCertificateChainIncomplete)) {
                // put all certificates of the chain in the rejected folder
                const rejectAll = (certificates) => __awaiter(this, void 0, void 0, function* () {
                    for (const certificate of certificates) {
                        yield this.rejectCertificate(certificate);
                    }
                });
                rejectAll(certificates)
                    .then(() => {
                    callback(null, statusCode);
                })
                    .catch((err) => {
                    callback(err);
                });
                return;
            }
            callback(null, statusCode);
        });
    }
    getTrustStatus(certificate, callback) {
        this.isCertificateTrusted(certificate, (err, trustedStatus) => {
            callback(err, err ? undefined : node_opcua_status_code_1.StatusCodes[trustedStatus]);
        });
    }
    withLock2(action) {
        const _super = Object.create(null, {
            withLock2: { get: () => super.withLock2 }
        });
        return __awaiter(this, void 0, void 0, function* () {
            return yield _super.withLock2.call(this, action);
        });
    }
}
exports.OPCUACertificateManager = OPCUACertificateManager;
OPCUACertificateManager.defaultCertificateSubject = "/O=Sterfive/L=Orleans/C=FR";
OPCUACertificateManager.registry = new node_opcua_object_registry_1.ObjectRegistry();
// tslint:disable:no-var-requires
// tslint:disable:max-line-length
const thenify = require("thenify");
const opts = { multiArgs: false };
OPCUACertificateManager.prototype.checkCertificate = thenify.withCallback(OPCUACertificateManager.prototype.checkCertificate, opts);
OPCUACertificateManager.prototype.getTrustStatus = thenify.withCallback(OPCUACertificateManager.prototype.getTrustStatus, opts);
OPCUACertificateManager.prototype.initialize = thenify.withCallback(OPCUACertificateManager.prototype.initialize, opts);
function getDefaultCertificateManager(name) {
    const config = (0, env_paths_1.default)("node-opcua-default").config;
    const pkiFolder = path.join(config, name);
    return new OPCUACertificateManager({
        name,
        rootFolder: pkiFolder,
        automaticallyAcceptUnknownCertificate: true
    });
}
exports.getDefaultCertificateManager = getDefaultCertificateManager;
//# sourceMappingURL=certificate_manager.js.map